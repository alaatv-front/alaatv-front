<template>
  <div ref="shadow"
       class="parent-fix">
    <div ref="sticky"
         class="position-fix">
      <slot />
    </div>
  </div>
</template>

<script>
export default {
  name: 'StickyBothSides',
  inject: {
    scrollInfo: {
      from: 'scrollInfo',
      default: {}
    }
  },
  props: {
    maxWidth: {
      type: Number,
      default: 0
    },
    topGap: {
      type: Number,
      default: 0
    },
    bottomGap: {
      type: Number,
      default: 0
    }
  },
  data () {
    return {
      disableSticky: false,
      windowWidth: 0,
      stickyElementWidth: 0,
      start: 0,
      previousPosition: 0
    }
  },
  computed: {
    stickyElement () {
      return this.$refs.sticky
    },
    shadowElement () {
      return this.$refs.shadow
    }
  },
  watch: {
    scrollInfo (newValue) {
      if (!this.disableSticky) {
        this.updateScroll(newValue)
      } else {
        this.stickyElement.style.position = 'static'
      }
    }
  },
  mounted () {
    this.windowWidth = window.innerWidth
    if (this.windowWidth < this.maxWidth) {
      this.disableSticky = true
    }
    window.addEventListener('resize', this.onResize)
    this.getStartFixElementPosition()
    this.stickyElementWidth = this.shadowElement.offsetWidth
  },
  beforeUnmount () {
    window.removeEventListener('resize', this.onResize)
  },
  methods: {
    onResize () {
      this.windowWidth = window.innerWidth
      this.disableSticky = this.windowWidth < this.maxWidth
      this.stickyElement.style.width = this.shadowElement.offsetWidth + 'px'
      this.stickyElementWidth = this.shadowElement.offsetWidth
    },
    getStartFixElementPosition () {
      this.start = this.$refs.sticky.getBoundingClientRect().top - this.topGap
    },
    getScrollY () {
      return window.scrollY
    },
    stickyElementToTop (stickyElementTop) {
      if (this.stickyElement.offsetHeight + this.topGap <= window.innerHeight) {
        if (this.getScrollY() <= this.start) {
          this.stickyElement.style.position = 'static'
        }
      } else {
        if (stickyElementTop < this.topGap) {
          stickyElementTop += this.previousPosition - this.getScrollY()
          this.stickyElement.style.top = stickyElementTop + 'px'
        } else if (this.getScrollY() <= this.start) {
          this.stickyElement.style.position = 'static'
        }
      }
    },
    stickyElementToBottom (stickyElementTop) {
      if (this.stickyElement.offsetHeight + this.topGap <= window.innerHeight) {
        if (this.getScrollY() >= this.start) {
          this.stickyElement.style.position = 'fixed'
          this.stickyElement.style.top = this.topGap + 'px'
          this.stickyElement.style.width = this.stickyElementWidth + 'px'
        }
      } else {
        if (this.stickyElement.getBoundingClientRect().bottom + this.bottomGap <= window.innerHeight) {
          this.stickyElement.style.position = 'fixed'
          this.stickyElement.style.top = window.innerHeight - this.bottomGap - this.stickyElement.offsetHeight + 'px'
          this.stickyElement.style.width = this.stickyElementWidth + 'px'
        } else if (stickyElementTop > window.innerHeight - this.stickyElement.offsetHeight) {
          stickyElementTop = stickyElementTop - (this.getScrollY() - this.previousPosition)
          this.stickyElement.style.top = stickyElementTop + 'px'
        }
      }
    },
    updateScroll (info) {
      const stickyElementTop = parseInt(this.stickyElement.style.top.replace('px', ''))
      if (info.direction === 'up') {
        this.stickyElementToTop(stickyElementTop)
      } else if (info.direction === 'down') {
        this.stickyElementToBottom(stickyElementTop)
      }
      this.previousPosition = this.getScrollY()
    }
  }
}
</script>

<style lang="scss" scoped>
.position-fix {
  position: static;
}
</style>
